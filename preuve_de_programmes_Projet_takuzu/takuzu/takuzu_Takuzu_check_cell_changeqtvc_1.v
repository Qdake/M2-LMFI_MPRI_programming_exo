(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a)
    (i:Numbers.BinNums.Z) : a :=
  elts a1 i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)) /\
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((mixfix_lbrb (make n v) i) = v)) /\
  ((length (make n v)) = n).

Parameter us_FORMULA_TO_BE_COMPLETED__: Prop.

Parameter us_TERM_TO_BE_COMPLETED__: forall {a:Type} {a_WT:WhyType a}, a.

Parameter us_VARIANT_TO_BE_COMPLETED__: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive elem :=
  | Zero : elem
  | One : elem
  | Empty : elem.
Axiom elem_WhyType : WhyType elem.
Existing Instance elem_WhyType.

(* Why3 assumption *)
Definition takuzu_grid := array elem.

(* Why3 assumption *)
Definition row_start_index (n:Numbers.BinNums.Z) : Numbers.BinNums.Z :=
  (8%Z * (ZArith.BinInt.Z.quot n 8%Z))%Z.

(* Why3 assumption *)
Definition valid_chunk (s:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) : Prop :=
  (i = 1%Z) /\
  ((0%Z <= s)%Z /\ (s <= 56%Z)%Z) /\ ((ZArith.BinInt.Z.rem s 8%Z) = 0%Z) \/
  (i = 8%Z) /\ (0%Z <= s)%Z /\ (s <= 7%Z)%Z.

Axiom valid_chunk1 :
  forall (s:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), valid_chunk s i ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < 8%Z)%Z ->
  (0%Z <= (s + (k * i)%Z)%Z)%Z /\ ((s + (k * i)%Z)%Z < 64%Z)%Z.

(* Why3 assumption *)
Definition acc (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) : elem :=
  mixfix_lbrb g (start + (incr * k)%Z)%Z.

(* Why3 assumption *)
Definition no_3_consecutive_identical_elem (g:array elem)
    (start:Numbers.BinNums.Z) (incr:Numbers.BinNums.Z)
    (l:Numbers.BinNums.Z) : Prop :=
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k <= (l - 3%Z)%Z)%Z ->
  ~ (((mixfix_lbrb g (start + (incr * k)%Z)%Z) =
      (mixfix_lbrb g (start + (incr * (k + 1%Z)%Z)%Z)%Z)) /\
     ((mixfix_lbrb g (start + (incr * (k + 1%Z)%Z)%Z)%Z) =
      (mixfix_lbrb g (start + (incr * (k + 2%Z)%Z)%Z)%Z)) /\
     ((mixfix_lbrb g (start + (incr * (k + 2%Z)%Z)%Z)%Z) = One)) /\
  ~ (((mixfix_lbrb g (start + (incr * k)%Z)%Z) =
      (mixfix_lbrb g (start + (incr * (k + 1%Z)%Z)%Z)%Z)) /\
     ((mixfix_lbrb g (start + (incr * (k + 1%Z)%Z)%Z)%Z) =
      (mixfix_lbrb g (start + (incr * (k + 2%Z)%Z)%Z)%Z)) /\
     ((mixfix_lbrb g (start + (incr * (k + 2%Z)%Z)%Z)%Z) = Zero)).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Parameter num_occ:
  elem -> array elem -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter if_term:
  elem -> array elem -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom if_term'def :
  forall (e:elem) (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) (l:Numbers.BinNums.Z),
  (((acc g start incr (l - 1%Z)%Z) = e) ->
   ((if_term e g start incr l) = Init.Datatypes.true)) /\
  (~ ((acc g start incr (l - 1%Z)%Z) = e) ->
   ((if_term e g start incr l) = Init.Datatypes.false)).

Axiom num_occ'def :
  forall (e:elem) (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) (l:Numbers.BinNums.Z),
  ((length g) = 64%Z) -> valid_chunk start incr ->
  (0%Z <= l)%Z /\ (l <= 8%Z)%Z ->
  ((l = 0%Z) -> ((num_occ e g start incr l) = 0%Z)) /\
  (~ (l = 0%Z) ->
   match if_term e g start incr l with
   | Init.Datatypes.true =>
       ((num_occ e g start incr l) =
        (1%Z + (num_occ e g start incr (l - 1%Z)%Z))%Z)
   | Init.Datatypes.false =>
       ((num_occ e g start incr l) = (num_occ e g start incr (l - 1%Z)%Z))
   end).

(* Why3 assumption *)
Definition rule_2_for_chunk (g:array elem) (start:Numbers.BinNums.Z)
    (incr:Numbers.BinNums.Z) : Prop :=
  ((num_occ Zero g start incr 8%Z) <= 4%Z)%Z /\
  ((num_occ One g start incr 8%Z) <= 4%Z)%Z.

(* Why3 assumption *)
Definition identical_chunks (g:array elem) (s1:Numbers.BinNums.Z)
    (s2:Numbers.BinNums.Z) (incr:Numbers.BinNums.Z) (l:Numbers.BinNums.Z) :
    Prop :=
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < l)%Z ->
  ((acc g s1 incr k) = (acc g s2 incr k)) /\ ~ ((acc g s1 incr k) = Empty).

(* Why3 assumption *)
Definition rule_1_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  no_3_consecutive_identical_elem g (ZArith.BinInt.Z.rem n 8%Z) 8%Z 8%Z /\
  no_3_consecutive_identical_elem g (row_start_index n) 1%Z 8%Z.

(* Why3 assumption *)
Definition rule_2_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  rule_2_for_chunk g (ZArith.BinInt.Z.rem n 8%Z) 8%Z /\
  rule_2_for_chunk g (row_start_index n) 1%Z.

(* Why3 assumption *)
Definition rule_3_for_cell (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  let cs := ZArith.BinInt.Z.rem n 8%Z in
  let rs := row_start_index n in
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
  (~ (i = cs) -> ~ identical_chunks g cs i 8%Z 8%Z) /\
  (~ ((8%Z * i)%Z = rs) -> ~ identical_chunks g rs (8%Z * i)%Z 1%Z 8%Z).

(* Why3 assumption *)
Definition valid_for_cell (g:array elem) (i:Numbers.BinNums.Z) : Prop :=
  rule_1_for_cell g i /\ rule_2_for_cell g i /\ rule_3_for_cell g i.

(* Why3 assumption *)
Definition valid_up_to (g:array elem) (n:Numbers.BinNums.Z) : Prop :=
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  valid_for_cell g i.

Axiom subst_0 :
  forall (g:array elem) (n:Numbers.BinNums.Z) (e:elem),
  (0%Z <= n)%Z /\ (n < (length g))%Z ->
  ((mixfix_lblsmnrb (mixfix_lblsmnrb g n e) n Empty) =
   (mixfix_lblsmnrb g n Empty)).

Axiom aux_rule_1_and_rule_2_for_chunk :
  forall (g:array elem) (n:Numbers.BinNums.Z),
  ((length g) = 64%Z) /\ (0%Z <= n)%Z /\ (n < 64%Z)%Z ->
  (forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
   (let ck := ZArith.BinInt.Z.rem k 8%Z in
    let rk := row_start_index k in
    let cn := ZArith.BinInt.Z.rem n 8%Z in
    let rn := row_start_index n in
    (~ (ck = cn) ->
     no_3_consecutive_identical_elem (mixfix_lblsmnrb g n Empty) ck 8%Z 8%Z) /\
    (~ (rk = rn) ->
     no_3_consecutive_identical_elem (mixfix_lblsmnrb g n Empty) rk 1%Z 8%Z) /\
    (~ (ck = cn) -> rule_2_for_chunk (mixfix_lblsmnrb g n Empty) ck 8%Z) /\
    (~ (rk = rn) -> rule_2_for_chunk (mixfix_lblsmnrb g n Empty) rk 1%Z))) ->
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
  let ck := ZArith.BinInt.Z.rem k 8%Z in
  let rk := row_start_index k in
  let cn := ZArith.BinInt.Z.rem n 8%Z in
  let rn := row_start_index n in
  (~ (ck = cn) -> no_3_consecutive_identical_elem g ck 8%Z 8%Z) /\
  (~ (rk = rn) -> no_3_consecutive_identical_elem g rk 1%Z 8%Z) /\
  (~ (ck = cn) -> rule_2_for_chunk g ck 8%Z) /\
  (~ (rk = rn) -> rule_2_for_chunk g rk 1%Z).

Axiom sym :
  forall (g:array elem) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  ((0%Z <= m)%Z /\ (m < (length g))%Z) /\
  ((0%Z <= n)%Z /\ (n <= (length g))%Z) /\ ~ (m = n) ->
  (~ identical_chunks g m n 1%Z 8%Z -> ~ identical_chunks g n m 1%Z 8%Z) /\
  (~ identical_chunks g m n 8%Z 8%Z -> ~ identical_chunks g n m 8%Z 8%Z).

Axiom inv_not_identical :
  forall (g:array elem) (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  ((length g) = 64%Z) /\
  ((0%Z <= n)%Z /\ (n < (length g))%Z) /\ (0%Z <= k)%Z /\ (k < n)%Z ->
  let cs := ZArith.BinInt.Z.rem k 8%Z in
  let rs := row_start_index k in
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
  (~ (i = cs) /\
   ~ (cs = (ZArith.BinInt.Z.rem n 8%Z)) /\
   ~ (i = (ZArith.BinInt.Z.rem n 8%Z)) ->
   ~ identical_chunks (mixfix_lblsmnrb g n Empty) cs i 8%Z 8%Z <->
   ~ identical_chunks g cs i 8%Z 8%Z) /\
  (~ ((8%Z * i)%Z = rs) /\
   ~ (rs = (row_start_index n)) /\ ~ ((8%Z * i)%Z = (row_start_index n)) ->
   ~ identical_chunks (mixfix_lblsmnrb g n Empty) rs (8%Z * i)%Z 1%Z 8%Z <->
   ~ identical_chunks g rs (8%Z * i)%Z 1%Z 8%Z).

Parameter g: array elem.

Parameter n: Numbers.BinNums.Z.

Parameter e: elem.

Axiom H : ((length g) = 64%Z).

Axiom H1 : (0%Z <= n)%Z.

Axiom H2 : (n < 64%Z)%Z.

Axiom Requires : valid_up_to (mixfix_lblsmnrb g n Empty) n.

Parameter g1: array elem.

Axiom H3 : ((length g1) = (length g)).

Axiom Ensures : ((elts g1) = (map.Map.set (elts g) n e)).

Axiom Ensures1 : (g1 = (mixfix_lblsmnrb g n e)).

Axiom Assert : valid_up_to (mixfix_lblsmnrb g1 n Empty) n.

Axiom Ensures2 : valid_for_cell g1 n.

Axiom Ensures3 : True.

Axiom Assert1 : valid_for_cell g1 n.

Axiom Assert2 :
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
  let ck := ZArith.BinInt.Z.rem k 8%Z in
  let rk := row_start_index k in
  let cn := ZArith.BinInt.Z.rem n 8%Z in
  let rn := row_start_index n in
  (~ (ck = cn) -> no_3_consecutive_identical_elem g1 ck 8%Z 8%Z) /\
  (~ (rk = rn) -> no_3_consecutive_identical_elem g1 rk 1%Z 8%Z) /\
  (~ (ck = cn) -> rule_2_for_chunk g1 ck 8%Z) /\
  (~ (rk = rn) -> rule_2_for_chunk g1 rk 1%Z).

Axiom Assert3 :
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
  rule_1_for_cell g1 k.

Axiom Assert4 :
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
  rule_2_for_cell g1 k.

Axiom Assert5 : rule_3_for_cell g1 n.

Axiom Assert6 :
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
  (~ (i = (ZArith.BinInt.Z.rem n 8%Z)) ->
   ~ identical_chunks g1 (ZArith.BinInt.Z.rem n 8%Z) i 8%Z 8%Z) /\
  (~ ((8%Z * i)%Z = (row_start_index n)) ->
   ~ identical_chunks g1 (row_start_index n) (8%Z * i)%Z 1%Z 8%Z).

Axiom Assert7 :
  forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < n)%Z ->
  (~ ((ZArith.BinInt.Z.rem k 8%Z) = (ZArith.BinInt.Z.rem n 8%Z)) ->
   ~ identical_chunks g1 (ZArith.BinInt.Z.rem k 8%Z)
     (ZArith.BinInt.Z.rem n 8%Z) 8%Z 8%Z) /\
  (~ ((row_start_index k) = (row_start_index n)) ->
   ~ identical_chunks g1 (row_start_index k) (row_start_index n) 1%Z 8%Z).

Parameter k: Numbers.BinNums.Z.

Axiom H4 : (0%Z <= k)%Z.

Axiom H5 : (k < n)%Z.

Parameter i: Numbers.BinNums.Z.

Axiom H6 : (0%Z <= i)%Z.

Axiom H7 : (i < 8%Z)%Z.

(* Why3 goal *)
Theorem check_cell_change'vc :
  (~ (i = (ZArith.BinInt.Z.rem k 8%Z)) /\
   ~ ((ZArith.BinInt.Z.rem k 8%Z) = (ZArith.BinInt.Z.rem n 8%Z)) /\
   ~ (i = (ZArith.BinInt.Z.rem n 8%Z)) ->
   ~ identical_chunks (mixfix_lblsmnrb g1 n Empty)
     (ZArith.BinInt.Z.rem k 8%Z) i 8%Z 8%Z) /\
  (~ ((8%Z * i)%Z = (row_start_index k)) /\
   ~ ((row_start_index k) = (row_start_index n)) /\
   ~ ((8%Z * i)%Z = (row_start_index n)) ->
   ~ identical_chunks (mixfix_lblsmnrb g1 n Empty) (row_start_index k)
     (8%Z * i)%Z 1%Z 8%Z).
Proof.


Qed.

